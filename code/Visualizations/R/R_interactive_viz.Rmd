---
title: "Network Viz"
output:
  html_document:
    df_print: paged
  pdf_document: default
---


### Loading libraries
```{r message=FALSE, warning=FALSE, include=TRUE}

library(sf)
library(tidyverse)
library(leaflet)
library(mapview); mapviewOptions(platform = 'leafgl')
library(glue)
library(stringr)


```



### Load Canada Shape File into R and Save Vancouver Polygons as a Checkpoint

```{r}
# Import score data (long table)
allblocks <- read.csv("../../../data/score_sets/newest_long_scores.csv", stringsAsFactors = TRUE)
allblocks$fromId <- as.character(allblocks$fromId)

# Import shape file data
# keep necessary columns and rows for shp
canada_dbs <- st_read("../../../code/Visualizations/census2016_DBS_shp/DB_Van_CMA/DB_Van_CMA.shp", stringsAsFactors = FALSE)
van_dbs <- data.frame(canada_dbs[which(canada_dbs$CMANAME == "Vancouver"), ])[, c(1, 28)]

# join factor and geometry data 
van_dbs_scores <- right_join(van_dbs, allblocks, by = c('DBUID' = 'fromId'))

# convert back to sf object
van_dbs_scores_sf <- st_as_sf(van_dbs_scores)
van_dbs_scores_st <- st_transform(van_dbs_scores_sf, crs = 4326)

```




## Visualizing and Saving

```{r}

# Mapping function
map_maker_saver <- function(data, amenity, weight, nearest_n) {
  
  amn_name <- amenity %>% str_to_title() %>% str_replace_all('Or', 'or') %>% str_replace('And', 'and') %>% str_replace('/Performance', '')
  print(glue('{amn_name} Transit Accessibility - Weighted ({weight}) - Nearest Amenities ({str_to_upper(nearest_n)})'))

  
  # subset info
  polyg_subset <- data[data$type == amenity & data$weight == weight & data$nearest_n == nearest_n, ]
  
  # score vector
  score_vec <- polyg_subset$score
  
  # view 
  #plot(polyg_subset$geometry)
  
  
  # colour palette 
  Rd2Gn <- c("#e30606", "#fd8d3c", "#ffe669", "#cdff5e", "#64ed56")
  pal_fun <- colorQuantile(palette = Rd2Gn, NULL, n = 5)
  
  # popup # percentile(score_vec),
  percentile <- ecdf(score_vec)
  p_popup <- paste0("<h5>Accessibility Percentile: ", round(percentile(score_vec), 2)*100, '%',"</h5>", 
                      "<br><strong>Block ID: ", polyg_subset$DBUID,"</strong>",
                      "<br><strong>Block Population: ", polyg_subset$pop,"</strong>",
                      "<br>Raw Score: ", round(score_vec, 2))
        
  map <- leaflet(data = polyg_subset) %>%
      addPolygons(
        stroke = FALSE,  # remove polygon borders
        fillColor = ~pal_fun(score_vec), # set fill colour with pallette fxn from aboc
        fillOpacity = 0.6, smoothFactor = 0.5, # aesthetics
        popup = p_popup) %>% # add message popup to each block
      addTiles() %>%
      setView(lng = -122.8, lat = 49.2, zoom = 11) %>%
      addLegend("topright",  # location
                pal=pal_fun,    # palette function
                values=~score_vec,  # value to be passed to palette function
                title = glue('{amn_name} Transit Access'))
  
  file_name <- glue('{amn_name} Transit Accessibility - Weighted ({weight}) - Nearest Amenities ({str_to_upper(nearest_n)})')

  mapshot(map, url = paste0(getwd(), glue("/New HTML Maps/{file_name}.html")))

}
```


```{r}

for (amenity in unique(allblocks$type)[4]) { 
  for (weight in unique(allblocks$weight)) {
    for (nearest_n in unique(allblocks$nearest_n)) {
      
      map_maker_saver(data = van_dbs_scores_st, amenity, weight, nearest_n)
      
    }
  }
}




```





# OLD

```{r}
#eval=FALSE, include=TRUE}

# geo data
# takes a long time // see google drive for the census file
canada_dbs <- st_read("Census_DBs_2016_Digital_Cartographic.gml")

# keep Vancouver rows
van_dbs <- data.frame(canada_dbs[which(canada_dbs$CMANAME == "Vancouver"), ])

# keep the gml.id, DBUID, and geometry columns
clean_van_dbs <- van_dbs[, c(1, 2, 29)]

# convert ID to character
clean_van_dbs$DBUID <- as.character(clean_van_dbs$DBUID)

# save checkpoint (this loses the CRS information unfortunately)
#st_write(clean_van_dbs, dsn = 'Vancouver_DBs_2016_Digital_Cartographic_Polygons.gml')
```


### Load Vancouver Shape File Checkpoint (not yet functional)

```{r}
# import Vancouver polygon checkpoint (cannot recover CRS information from checkpoint)
#van_dbs <- st_read('Vancouver_DBs_2016_Digital_Cartographic_Polygons.gml')
#clean_van_dbs <- data.frame(van_dbs[, 2:4])

head(clean_van_dbs)
```

### Load Score Sets

```{r}
# Function to recursively import score sets from score set directory
import_scores <- function(path) {
  
  # Get list of files in path directory
  data_files <- list.files(path = path, recursive=T)
  
  # Function to pull file data into R
  data_puller <- function(path, file) { data <- read.csv(glue::glue('{path}/{file}')) }
  data_list <- lapply(data_files, data_puller, path = path)
  
  # Remove the '.csv' from file endings
  indx_to_keep <- nchar(data_files)-4
  names(data_list) <- mapply(substr, data_files, start = 1, stop = indx_to_keep, USE.NAMES = FALSE)
  
  # reduce to a single dataframe
  scores <- data_list %>% reduce(left_join, by = c('fromId')) 
  names(scores) <- c('fromId', names(data_list))
  
  scores
}

scores <- import_scores("../../../data/score_sets")


# convert fromId column to character
scores$fromId <- as.character(scores$fromId)

head(scores)
```

### Join the shape file IDs with the score sets

```{r}

van_dbs_scores <- left_join(clean_van_dbs, scores, by = c('DBUID' = 'fromId')) 

# convert back to sf object
van_dbs_scores_sf <- st_as_sf(van_dbs_scores)

# plot geometry shapes to make sure everything worked
plot(van_dbs_scores_sf$geometry)

```



## Visualizing in leaflet

```{r}

score_visualizer <- function(st_obj, score_col, title) {
  
  score_vec <- st_obj[[score_col]]
  
  # colour palette
  Rd2Gn <- c("#e30606", "#fd8d3c", "#ffe669", "#cdff5e", "#64ed56")
  pal_fun <- colorQuantile(palette = Rd2Gn, NULL, n = 5)
  
  # interactive popup
  p_popup <- paste0("<strong>Accessibility:</strong>", score_vec)
  
  # plot
  plot <- leaflet(st_obj) %>%
    addPolygons(
      stroke = FALSE,  # remove polygon borders
      fillColor = ~pal_fun(score_vec), # set fill colour with pallette fxn
      fillOpacity = 0.5, smoothFactor = 0.5, # aesthetics
      popup = p_popup) %>% # add message popup to each block
    addTiles() %>%
    addLegend("topright",  
              pal=pal_fun, # palette function
              values=~score_vec,  # value to be passed to palette function
              title = title) # legend title
  plot
}


```

```{r}
# leaflet requires the sf object be reprojected
van_dbs_scores_st <- st_transform(van_dbs_scores_sf, crs = 4326)

# score column names
score.names <- names(van_dbs_scores_sf)[3:12]

# title names
title.vec <- score.names  %>% 
  str_replace_all('_', ' ') %>% 
  str_replace_all('  ', ' ') %>% 
  str_replace_all(' scores', '') %>% 
  str_replace_all('1', '') %>% 
  str_replace_all('3', ' 3') %>% 
  str_replace_all('destination', 'Cultural Amenities') %>% 
  str_replace_all('simulated weighted', '(weighted)') %>% 
  str_to_title() %>% 
  str_replace_all('O', 'o')


map_collection <- NULL

for (i in 1:length(score.names)) {
  temp_map <- score_visualizer(st_obj = van_dbs_scores_st,
                               score_col = score.names[i],
                               title = title.vec[i])
  
  mapshot(temp_map, url = paste0(getwd(), glue::glue("/{title.vec[i]}.html")))
  
  map_collection[i] <- temp_map
}


```
































