---
title: "Many-to-Many Point Computation Script"
author: "Luka Vukovic"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

### Loading libraries
```{r include=FALSE}

# Main
library(r5r)
#if (Sys.getenv("JAVA_HOME")!="")
#  Sys.setenv(JAVA_HOME="")
library(rJava)
library(sf)
library(data.table)

# Convenience
library(tidyverse)
library(glue)
library(rlist)

```


### 1. Setup the Network Graph

- If the vancouver_canada.osm.pbf file needs to be converted to an .osm, one can use a binary osm converter available at: https://wiki.openstreetmap.org/wiki/Osmconvert#Binaries

```{r message=FALSE, warning=FALSE}
## Allocate 4G RAM to Java
options(java.parameters = "-Xmx6g")

## Build transport network, pointing to path where OSM and GTFS data are located
r5r_core <- setup_r5(data_path = getwd(), verbose = FALSE)
```


### 2. Load origin/destination points

```{r, warning=FALSE}

# Dissemination Blocks
origins <- fread(file.path("../../data/clean", "vancouver_db.csv"))
paste('Origin Rows: ', nrow(origins))

origins <- origins[, c(1,3,4)]
colnames(origins)[1] <- 'id'
origins$id <- as.character(origins$id)  # numeric to char

# Peek
head(origins)
```

```{r message=FALSE, warning=FALSE}
# All facilities
destinations <- fread(file.path("../../data/efficiency", "vancouver_facilities.csv"))
paste('Original Destinations: ', nrow(destinations))


# See summary counts of each amenity
destinations %>% group_by(type) %>% summarise(count = n()) %>% arrange(desc(count))
destinations %>% summarise(count = n()) %>% arrange(desc(count))


# Keep only id, lat, and lon columns
destinations <- destinations[, 1:4]

destinations$lat <-  as.numeric(destinations$lat) # char to numeric
destinations$lon <-  as.numeric(destinations$lon) # char to numeric
destinations$id <- as.character(destinations$id)  # numeric to char
#destinations$id <- as.character(destinations$id)  # numeric to char

destinations <- destinations[complete.cases(destinations)] # remove NA rows
paste('Filtered Destinations: ', nrow(destinations))

# Peek
head(destinations)

```





### 3. Set constraints

```{r}
# Non-transit : WALK, BICYCLE, CAR, BICYCLE_RENT, CAR_PARK
# Transit: TRAM, SUBWAY, RAIL, BUS, FERRY, CABLE_CAR, GONDOLA, FUNICULAR
mode <- c('WALK')

max_walk_dist <- 1000 # 1 km

max_trip_duration <- 120 # 2 hours

```


### 4. Compute Expanded Travel Time Matrix

- We average transit times across all weekly transit schedules so we compute travel time on:
  - A weekday
  - Saturday
  - Sunday
- We also want average transit times across time of day so we compute travel times from:
  - 7am to 7pm at every hour mark with a departure window of 30 minutes.
  - A window of 1 equates to a 5 minute departure window so we will use 6.

```{r}
# default walk speed = 3.6 km/h

all_ttms <- list()
    
#departure_datetime <- as.POSIXct(glue("01-05-2021 00:00:00"), format="%d-%m-%Y %H:%M:%S")

ttm <- travel_time_matrix(r5r_core = r5r_core,
                      origins = origins,
                      destinations = destinations,
                      #departure_datetime = departure_datetime,
                      #time_window = 30,
                      
                      # constrains
                      mode = mode,
                      max_walk_dist = max_walk_dist,
                      max_trip_duration = max_trip_duration,
                     # max_rides = max_rides,
                      verbose = FALSE)

all_ttms <-  list.append(all_ttms, ttm) # very slow: rbind(all_ttm, ttm)

#print(glue('Progress: {round(((day-14)*12 + time-6)/37*100, 1)}%'))


# Fast way to bind all data.frames
TTM <- rbindlist(all_ttms)

print('COMPLETED')

summary(TTM)
```


### 5. Aggregate Travel Time Matrix 

```{r}
# aggregate on each unique transit trip to compute the avg time
# time to the same destination
TTM_agg <- TTM %>%
           group_by(fromId, toId) %>% 
           summarise(
             avg_time = mean(travel_time), 
             sd_time = sd(travel_time)
           )

paste('First aggregation:')
summary(TTM_agg)

```



### 6. Fix Odd Values in sd_time

```{r}

# replace NAs with median value
# even if these are rare trips (1 trip means NA in sd)
# the bus still probably comes on a regular schedule with uncertainty like most stops
median_sd <- median(TTM_agg$sd_time, na.rm=TRUE)
TTM_agg <- TTM_agg %>% replace_na(list('sd_time'=median_sd))

# replace <=1 with 1 to avoid large or infinity computations later on
TTM_agg$sd_time[(TTM_agg$sd_time <= 1)] <-  1

paste('Clean TTM Aggregation:')
summary(TTM_agg)
```

### 7. Export
```{r}
# Export for later manipulation
write.csv(TTM_agg, "../../data/efficiency/ttm_eff.csv", row.names = FALSE)

```

