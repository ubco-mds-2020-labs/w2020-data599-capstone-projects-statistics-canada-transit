---
title: "Travel Time Matrix to Maps"
output: html_notebook
---

## Notebook Purpose

This notebook serves to summarize the entire visualization process going from 
the travel time matrix to the visualizations. That involves the following 
sections:

1) Travel Time Matrix Wrangling
2) Score Computation
3) Isochrone Computation
4) Dataset Wrangling Part II (NA Insertion)
5) Interactive Visualization
6) Map HTML Exports

## 0) Useful Libraries

```{r message=FALSE, warning=FALSE, include=TRUE}
# import custom scoring, cleaning, and visualization functions
source('functions_eff.R')

# wrangling/convenience
library(tidyverse)
library(glue)
library(stringr)
library(sf)
library(data.table)
library(bit64)

# visualization
library(leaflet)
library(mapview); mapviewOptions(platform = 'leafgl')

# For pretty knitting
library(lemon)
knit_print.data.frame <- lemon_print
knit_print.tbl <- lemon_print
knit_print.summary <- lemon_print
```




## 1) Initial data wrangling
```{r}

# Function to calculate efficiency withing 'X' degrees of each block

#import scores
db_prox <- read.csv('../../data/clean/vancouver_Prox.csv', stringsAsFactors = FALSE)
scores_long <- read.csv('../../data/efficiency/initial_scores.csv', stringsAsFactors = FALSE)
origins <- fread(file.path("../../data/clean", "vancouver_db.csv"), stringsAsFactors = FALSE)[, .(id, pop, lat, lon)]
trafic_data <- read.csv('../../data/raw/BC_trafic_data_2015_summary.csv', stringsAsFactors = FALSE)[c(9,10,16:37)]

origins$pop <- str_replace_all(origins$pop, ',', '')

# change col types
db_prox[db_prox==".."]<-NA
db_prox[db_prox=="F"]<-NA
db_prox <- data.frame(lapply(db_prox,as.numeric))
scores_long$fromId <- as.factor(scores_long$fromId)
origins$pop <- as.numeric(origins$pop)  
origins$id <- as.factor(origins$id)  
db_prox$id <- as.factor(db_prox$id)
n_origins <- nrow(origins)
paste('Origin Rows: ', n_origins)
```

## 2) Calculation of the running efficiency score
## Calculate using existing proximity scores and traffic vehicle count
```{r}
origins_pos <- origins

#Get mean accessibility score for each block
scores_long_pos <-filter(scores_long,stringr::str_detect(nearest_n, '1') & stringr::str_detect(weight, 'no'))[,c(1,3)] %>% group_by(fromId) %>% summarise(mean_score = mean(score))

scores_pos <- left_join(scores_long_pos, origins_pos, by=c("fromId" = "id"), keep = FALSE)
scores_pos <- left_join(scores_pos, db_prox,  by=c("fromId" = "id"), keep = FALSE, set)

# Normalize the population of each block
scores_pos$pop_norm <- normalize_vec(scores_pos$pop)

# Get mean of all proximity measures within 500 m of each data block
scores_prox_score <- scores_pos[,c(1:5,16)]
scores_prox_score$prox_score <- normalize_vec(apply(scores_pos,1, rollingAvg_prox))

# Get most recent mean vehicle count of all instruments within 5 km of each data block
trafic_data$TraficCount <- apply(trafic_data, 1, getAll_Data)
scores_prox_score$scoreCorrection <- apply(scores_prox_score,1,db_trafic)
scores_prox_score$scoreCorrection[is.na(scores_prox_score$scoreCorrection)] <- mean(scores_prox_score$scoreCorrection, na.rm = TRUE)
scores_prox_score$scoreCorrection <- normalize_vec(scores_prox_score$scoreCorrection)

# Calculate efficiency score
scores_prox_score$eff <- normalize_vec_nonAbs((scores_prox_score$mean_score/scores_prox_score$scoreCorrection)-(scores_prox_score$pop_norm/scores_prox_score$prox_score))

#scores_prox_score$eff[scores_prox_score$fromId=='59151708030'] <- NA

# Calculate running efficiency score 
scores_prox_score$eff_ravg <- normalize_vec_nonAbs(apply(scores_prox_score,1, rollingAvg))

scores_prox_score$eff_ravg[scores_prox_score$fromId=='59151708030'] <- NA
scores_prox_score$eff_ravg <- normalize_vec_nonAbs(scores_prox_score$eff_ravg)

efficiency_frame <- scores_prox_score
```






## 3) Dataset Wrangling Part II (NA Insertion)

Each origin(fromId) should have x different scores where x is defined by:

x = 4 amenity options = 4

In addition to filling the empty NA rows for included IDs, there are also IDs
that need to be re-added as not a single time was computed for these IDs.


```{r}
paste0('EFFICIENCY FRAME')

# HOW MANY ROWS TO FILL IN EFFICIENCY FRAME?
N <- uniqueN(efficiency_frame$fromId) # expected rows
paste(glue('{nrow(efficiency_frame)} of {N} rows filled ({round((nrow(efficiency_frame) / N)*100, 2)}%)'))
paste(N - nrow(efficiency_frame), 'to fill.')

cat(paste0('\n')) # line break

# HOW MANY ROWS TO ADD IN EFFICIENCY FRAME?
# existing IDs that weren't included in ttm
missing_blocks <- array(setdiff(origins$id, efficiency_frame$fromId))
total_expected <- nrow(efficiency_frame) + length(missing_blocks) # only 4 values per origin
paste(glue('{nrow(efficiency_frame)} of {total_expected} rows filled ({round((nrow(efficiency_frame) / total_expected)*100, 2)}%)'))
paste(length(missing_blocks), 'to add')
```

```{r}

x <- 2

# fill NA for all existing origin IDs
filled_efficiency_frame <- NA_table_filler_eff(efficiency_frame)
# add missing NAs to efficiency frame
all_efficiency_frame <- NA_table_filler_eff(filled_efficiency_frame,
                                       custom_idx = missing_blocks)

# Remove duplicate rows
all_efficiency_frame <- all_efficiency_frame %>% group_by(fromId) %>% slice(which.max(!is.na(lat)))
```

```{r}

# check efficiency
# there should be 1 count per fromId
eff_id_counts <- all_efficiency_frame %>% group_by(fromId) %>% summarise(n = n())
unique(eff_id_counts$n)

```


# Now lets add population data to the efficiency frame

```{r}
# right join with origins to include origins without transit access

all_efficiency_frame <- right_join(all_efficiency_frame, origins, by = c('fromId' = 'id'))
all_efficiency_frame <- subset(all_efficiency_frame,select = -c(pop.x,lat.x,lon.x))
```

```{r}

## Export checkpoint
write.csv(all_efficiency_frame, '../../data/efficiency/efficiency_frame.csv', row.names = FALSE)

```


### Import the dissemination block shape file
```{r}
canada_shape <- st_read("../../data/census2016_DBS_shp/DB_Van_CMA/DB_Van_CMA.shp", stringsAsFactors = FALSE)

# select a greater metropolitan area
metropolitan_area <- "Vancouver"

# filter columns and rows
vancouver_shape <- data.frame(canada_shape[which(canada_shape$CMANAME == metropolitan_area), c(1, 28)])

# id to factor
vancouver_shape$DBUID <- as.factor(vancouver_shape$DBUID)

paste('Rows = ', nrow(vancouver_shape))
head(vancouver_shape)
```


## 4) Interactive Visualization
```{r}
# join factor and geometry data 
eff_viz_frame <- left_join(vancouver_shape, all_efficiency_frame, by = c('DBUID' = 'fromId'))

# convert back to sf object
eff_viz_frame_sf <- st_as_sf(eff_viz_frame)

# convert to st object
eff_viz_frame_st <- st_transform(eff_viz_frame_sf, crs = 4326)

```



## 5) Map HTML Exports

```{r}

map_maker_efficiency_num(data = eff_viz_frame_st,
                      output_dir = '../../data/html_maps/efficiency_maps')
map_maker_efficiency_quant(data = eff_viz_frame_st,
                      output_dir = '../../data/html_maps/efficiency_maps')

```





























